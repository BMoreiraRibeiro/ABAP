---
tags:
  - ABAP
  - Debug
  - ST22
  - Dumps
  - Erros
---

# An√°lise de Dumps (ST22)

## üìã Vis√£o Geral

A transa√ß√£o **ST22** permite analisar **dumps** (short dumps) - erros em runtime que causam o t√©rmino abrupto do programa. √â essencial para diagnosticar e corrigir problemas em produ√ß√£o.

---

## üéØ O que √© um Dump?

Um **dump** ocorre quando:
- Divis√£o por zero
- Acesso a √≠ndice inv√°lido de tabela
- Convers√£o de dados inv√°lida
- Timeout de programa
- Falta de mem√≥ria
- Autoriza√ß√£o insuficiente

**Exemplo de c√≥digo que gera dump:**
```abap
DATA: lv_result TYPE i,
      lv_divisor TYPE i VALUE 0.

lv_result = 10 / lv_divisor.  " ‚ùå DUMP: COMPUTE_INT_ZERODIVIDE
```

---

## üîπ Aceder √† ST22

### Transaction Code
```
ST22
```

### O que v√™s
- Lista de dumps recentes
- Filtros por data, utilizador, programa
- Detalhes completos de cada dump

---

## üîπ Estrutura de um Dump

### 1. Cabe√ßalho
```
Runtime Error: COMPUTE_INT_ZERODIVIDE
Date/Time: 04.11.2025 10:30:15
User: JSILVA
Program: Z_MEU_PROGRAMA
```

### 2. Descri√ß√£o do Erro
Explica√ß√£o em linguagem natural do que aconteceu.

### 3. Source Code Extract
C√≥digo onde o erro ocorreu:
```abap
18  DATA lv_divisor TYPE i VALUE 0.
19  
20  lv_result = 10 / lv_divisor.  " ‚Üê‚Üê‚Üê Erro aqui
21  
22  WRITE: / lv_result.
```

### 4. Call Stack (Pilha de Chamadas)
```
1. Z_MEU_PROGRAMA (Line 20)
2. PERFORM calcular (Line 15)
3. CLASS_METHOD processar (Line 45)
```

### 5. Conte√∫do de Vari√°veis
Valores das vari√°veis no momento do erro:
```
lv_result   = 0
lv_divisor  = 0
sy-subrc    = 0
sy-tabix    = 1
```

---

## üí° Erros Comuns e Solu√ß√µes

### 1. COMPUTE_INT_ZERODIVIDE

**Causa:** Divis√£o por zero

```abap
" ‚ùå Problema
lv_result = lv_a / lv_b.  " lv_b = 0

" ‚úÖ Solu√ß√£o
IF lv_b <> 0.
  lv_result = lv_a / lv_b.
ELSE.
  MESSAGE 'Divisor n√£o pode ser zero' TYPE 'E'.
ENDIF.
```

### 2. ITAB_LINE_NOT_FOUND

**Causa:** Acesso a linha inexistente de tabela

```abap
" ‚ùå Problema
DATA(ls_cliente) = lt_clientes[ 999 ].  " √çndice n√£o existe

" ‚úÖ Solu√ß√£o 1: READ TABLE com sy-subrc
READ TABLE lt_clientes INTO DATA(ls_cliente) INDEX 999.
IF sy-subrc = 0.
  " Processar
ENDIF.

" ‚úÖ Solu√ß√£o 2: Express√£o com OPTIONAL
DATA(ls_cliente) = VALUE #( lt_clientes[ 999 ] OPTIONAL ).
IF ls_cliente IS NOT INITIAL.
  " Processar
ENDIF.
```

### 3. CONVT_NO_NUMBER

**Causa:** Convers√£o inv√°lida de texto para n√∫mero

```abap
" ‚ùå Problema
DATA: lv_texto TYPE string VALUE 'ABC',
      lv_numero TYPE i.
lv_numero = lv_texto.  " Erro!

" ‚úÖ Solu√ß√£o
TRY.
    lv_numero = lv_texto.
  CATCH cx_sy_conversion_no_number.
    MESSAGE 'Valor n√£o √© num√©rico' TYPE 'E'.
ENDTRY.
```

### 4. TSV_TNEW_PAGE_ALLOC_FAILED

**Causa:** Falta de mem√≥ria (tabela muito grande)

```abap
" ‚ùå Problema
SELECT * FROM ekko INTO TABLE lt_docs.  " Milh√µes de registos!

" ‚úÖ Solu√ß√£o 1: Limitar quantidade
SELECT * FROM ekko INTO TABLE lt_docs UP TO 10000 ROWS.

" ‚úÖ Solu√ß√£o 2: Processar em pacotes
SELECT * FROM ekko INTO TABLE @DATA(lt_pacote)
  PACKAGE SIZE 1000.
  " Processar lt_pacote
ENDSELECT.
```

### 5. MOVE_CAST_ERROR

**Causa:** Cast de objeto inv√°lido

```abap
" ‚ùå Problema
DATA: lo_animal TYPE REF TO lcl_animal.
lo_animal = NEW lcl_cao( ).
DATA(lo_gato) = CAST lcl_gato( lo_animal ).  " Erro! N√£o √© gato

" ‚úÖ Solu√ß√£o
IF lo_animal IS INSTANCE OF lcl_gato.
  DATA(lo_gato) = CAST lcl_gato( lo_animal ).
ELSE.
  MESSAGE 'Objeto n√£o √© do tipo esperado' TYPE 'E'.
ENDIF.
```

### 6. TIME_OUT

**Causa:** Programa excedeu tempo m√°ximo

```abap
" ‚ùå Problema
DO 999999999 TIMES.
  " Loop infinito
ENDDO.

" ‚úÖ Solu√ß√£o
DATA lv_max TYPE i VALUE 1000.
DO lv_max TIMES.
  " Processar
  IF sy-index >= lv_max.
    EXIT.
  ENDIF.
ENDDO.
```

---

## üîç Como Analisar um Dump

### Passo 1: Identificar o Erro

```
Runtime Error: ITAB_LINE_NOT_FOUND
```
**Pergunta:** O que aconteceu?

### Passo 2: Ver C√≥digo Fonte

```abap
20  DATA(ls_linha) = lt_tabela[ 100 ].  " ‚Üê‚Üê‚Üê Aqui
```
**Pergunta:** Onde aconteceu?

### Passo 3: Analisar Call Stack

```
1. Z_PROGRAMA (Line 20)
2. FORM processar_dados (Line 15)
3. Main Program (Line 5)
```
**Pergunta:** Como cheg√°mos aqui?

### Passo 4: Verificar Vari√°veis

```
lt_tabela: 50 linhas
sy-index: 100
```
**Pergunta:** Qual era o estado?

### Passo 5: Entender Causa Raiz

**Conclus√£o:** Tentei aceder √† linha 100, mas tabela s√≥ tem 50 linhas.

### Passo 6: Corrigir

```abap
" ‚úÖ Solu√ß√£o
IF lines( lt_tabela ) >= 100.
  DATA(ls_linha) = lt_tabela[ 100 ].
ELSE.
  MESSAGE 'Tabela n√£o tem linhas suficientes' TYPE 'E'.
ENDIF.
```

---

## üõ†Ô∏è Funcionalidades da ST22

### Filtros

```
- Por data
- Por utilizador
- Por programa
- Por tipo de erro
- Por servidor
```

### A√ß√µes

- **Analisar**: Ver detalhes completos
- **Repetir**: Tentar reproduzir (apenas em desenvolvimento)
- **Arquivar**: Marcar como resolvido
- **Exportar**: Guardar detalhes

---

## üìä Estat√≠sticas de Dumps

**ST22 ‚Üí Analysis ‚Üí Statistics**

Ver:
- Dumps mais frequentes
- Programas com mais problemas
- Utilizadores afetados
- Tend√™ncias ao longo do tempo

---

## üí° Exemplo Completo de An√°lise

### Dump Recebido

```
Runtime Error: ITAB_LINE_NOT_FOUND
Program: Z_RELATORIO_VENDAS
User: VENDEDOR01
Date: 04.11.2025 14:30:00
```

### C√≥digo com Erro

```abap
45  LOOP AT lt_vendas INTO DATA(ls_venda).
46    DATA(ls_cliente) = lt_clientes[ kunnr = ls_venda-kunnr ].
47    WRITE: / ls_cliente-name1, ls_venda-netwr.
48  ENDLOOP.
```

### Call Stack

```
Z_RELATORIO_VENDAS (Line 46)
```

### Vari√°veis

```
lt_vendas: 100 linhas
lt_clientes: 80 linhas
ls_venda-kunnr: '0000099999'
```

### An√°lise

1. **Problema**: Cliente '0000099999' n√£o existe em lt_clientes
2. **Causa**: Dados inconsistentes (venda sem cliente)
3. **Solu√ß√£o**: Usar READ TABLE com verifica√ß√£o

### Corre√ß√£o

```abap
LOOP AT lt_vendas INTO DATA(ls_venda).
  READ TABLE lt_clientes INTO DATA(ls_cliente)
    WITH KEY kunnr = ls_venda-kunnr.
    
  IF sy-subrc = 0.
    WRITE: / ls_cliente-name1, ls_venda-netwr.
  ELSE.
    WRITE: / 'Cliente n√£o encontrado:', ls_venda-kunnr.
  ENDIF.
ENDLOOP.
```

---

## üéì Boas Pr√°ticas

### ‚úÖ Fazer

```abap
" 1. Sempre verificar sy-subrc
READ TABLE lt_tab INTO ls_linha INDEX 1.
IF sy-subrc = 0.
  " OK
ENDIF.

" 2. Usar TRY-CATCH para convers√µes
TRY.
    lv_numero = lv_texto.
  CATCH cx_sy_conversion_error.
    " Tratar erro
ENDTRY.

" 3. Validar antes de aceder
IF lines( lt_tab ) > 0.
  DATA(ls_first) = lt_tab[ 1 ].
ENDIF.

" 4. Limitar SELECTs
SELECT * FROM tabela INTO TABLE lt_data UP TO 10000 ROWS.
```

### ‚ùå Evitar

```abap
" 1. Acesso direto sem valida√ß√£o
DATA(ls_linha) = lt_tab[ 1 ].  " ‚ùå Pode n√£o existir

" 2. Ignorar possibilidade de erro
lv_numero = lv_texto.  " ‚ùå Pode n√£o ser n√∫mero

" 3. SELECTs sem limite
SELECT * FROM tabela.  " ‚ùå Pode trazer milh√µes

" 4. N√£o documentar erros conhecidos
" Se conhece o problema, documente!
```

---

## üîó Transactions Relacionadas

- **ST22** - An√°lise de dumps
- **SM21** - System log (eventos do sistema)
- **ST11** - Developer traces
- **SM50** - Process overview
- **SAT** - Runtime analysis

---

## üîó Pr√≥ximos Passos

- **[SAT](5_sat.md)** - Analisar performance
- **[Debugger](3_debugger.md)** - Prevenir dumps com debug
- **[Watchpoints](2_watchpoints.md)** - Rastrear mudan√ßas

---

**Tags:** `#Debug` `#ST22` `#Dumps` `#Erros` `#Troubleshooting` `#ABAP`
